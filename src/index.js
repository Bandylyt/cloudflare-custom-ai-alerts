// Get time window for last 24 hours
const getTimeWindow = () => {
    const now = new Date();
    const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    return {
        start: twentyFourHoursAgo.toISOString(),
        end: now.toISOString()
    };
};

// KV Key for state comparison
const STATE_KEY = 'security_events_state';

/*
Simple hash function for state comparison 
JSON.stringify(data) - Converts the data to a string
btoa() - Converts the string to base64
slice(0, 32) - Takes first 64 characters
Crypto API can be used to generate a more secure hash if needed
*/
const getSimpleHash = (data) => {
    return btoa(JSON.stringify(data)).slice(0, 64);
};

// AI Analysis function
const analyzeWithAI = async (events, env) => {
    const prompt = `As a SOC analyst, provide a concise security analysis of these Security events generated by Cloudflare. Format your response exactly like this example:

 Your task is to:
- **Aggregate and analyze** similar events (based on IP, JA4, ASN, path, rule descriptions).
- **Identify attack types** (e.g., reconnaissance, brute force, vulnerability scan, etc.).
- **Assess severity** based on volume (count), action taken, and sensitivity of path.
- **Recognize patterns** (e.g., repeated access to .env, low bot score, known malicious ASN, etc.).
- **Highlight key indicators** from structured fields.

Format exactly like this:

**Attack Summary:**
Brief 2-3 line summary of the attack type, target, and scale.

**Severity Assessment:**
Risk Level: [Critical/High/Medium/Low]
Impact: 1-2 lines about business impact

**Key Indicators:**
• Geographic: [Countries/Regions]
• ASNs: [List of ASNs]
• Target: [Specific endpoints]
• Pattern: [Attack characteristics]
• JA4 Fingerprints: [Client fingerprint patterns]
• Triggered Rules: [List of security rule names/descriptions]

**Recommended Actions:**
1. Immediate: [2-3 critical steps]
2. Mitigation: [2-3 key strategies]
3. Long-term: [2-3 important improvements]

Events: ${JSON.stringify(events, null, 2)}`;

    try {
        const aiResponse = await env.AI.run('@cf/meta/llama-4-scout-17b-16e-instruct', {
            messages: [{
                role: "system",
                content: "You are a professional SOC analyst reviewing structured security event logs from Cloudflare. Provide concise, well-formatted security analysis. Keep responses brief and focused. Use bullet points and clear sections. Avoid lengthy explanations. NOTE: Similar Ja4 can be recommended to identify and block attack traffic as Immediate action"
            }, {
                role: "user",
                content: prompt
            }],
            temperature: 0.2,  // Lower temperature for more consistent formatting
            max_tokens: 500,   // Reduced for more concise responses
            top_p: 0.8,       // More focused responses
            top_k: 30,        // More focused token selection
            repetition_penalty: 1.1,
            presence_penalty: 0.3,
            frequency_penalty: 0.2
        });

        // Extract the text content from the AI response
        return aiResponse.response || aiResponse.text || JSON.stringify(aiResponse, null, 2);
    } catch (error) {
        console.error('AI analysis failed:', error);
        return "AI analysis unavailable. Please check raw events.";
    }
};

// Send alert to Google Chat
const sendAlert = async (events, env) => {
    // Get AI analysis
    const aiAnalysis = await analyzeWithAI(events, env);
    
    // Calculate attack metrics
    const totalRequests = events.reduce((sum, event) => sum + event.count, 0);
    const uniqueIPs = new Set(events.map(e => e.dimensions.clientIP)).size;
    const countries = new Set(events.map(e => e.dimensions.clientCountryName));
    const paths = new Set(events.map(e => e.dimensions.clientRequestPath));
    const actions = new Set(events.map(e => e.dimensions.action));
    const asns = new Set(events.map(e => e.dimensions.clientAsn));
    const responseStatuses = new Set(events.map(e => e.dimensions.edgeResponseStatus));
    const ja4Fingerprints = new Set(events.map(e => e.dimensions.ja4));
    const ruleNames = new Set(events.map(e => e.dimensions.description));

    const cardMessage = {
        cards: [
            {
                header: {
                    title: `🚨 Security Events Detected on **zone_name** 🚨`,
                    subtitle: `From: Cloudflare Workers || Time: ${new Date().toISOString()}`
                },
                sections: [
                    {
                        widgets: [
                            {
                                textParagraph: {
                                    text: `📊 Attack Metrics:
• Total Requests: ${totalRequests}
• Unique IPs: ${uniqueIPs}
• Countries: ${Array.from(countries).join(', ')}
• ASNs: ${Array.from(asns).join(', ')}
• Actions: ${Array.from(actions).join(', ')}
• Response Statuses: ${Array.from(responseStatuses).join(', ')}
• JA4 Fingerprints: ${Array.from(ja4Fingerprints).join(', ')}
• Targeted Paths: ${Array.from(paths).join(', ')}
• Triggered Rules: ${Array.from(ruleNames).join(', ')}`
                                }
                            }
                        ]
                    },
                    {
                        widgets: [
                            {
                                textParagraph: {
                                    text: `🔍 AI Analysis:\n${aiAnalysis}`
                                }
                            }
                        ]
                    },
                    {
                        widgets: [
                            {
                                textParagraph: {
                                    text: `📝 Raw Events:\n${JSON.stringify(events, null, 2)}`
                                }
                            }
                        ]
                    }
                ]
            }
        ]
    };

    try {
        const response = await fetch(env.WEBHOOK_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(cardMessage)
        });

        if (!response.ok) {
            throw new Error(`Webhook failed with status: ${response.status}`);
        }
        console.log('Alert sent successfully');
    } catch (error) {
        console.error('Failed to send alert:', error);
    }
};

console.log("getSimpleHash", getSimpleHash)

/*
To monitor sepcific rulesets like cusotm rules , rate limit rules, etc. add filter : rulesetId_like: "${rlrulesetId}" to Graphql Query

Note: 
1. Limit set is 25 events, if you want to monitor more events, increase the limit in the Graphql Query; However, consider Model Token Limit and response time.
2. For llama 4 scout 17b,context window is 131,000 tokens.
3. Each event is approx 100 tokens, so max ~ 1300 events can be processed in one call.
*/

// Scheduled Handler worker
export default {

	async scheduled(event, env, ctx) {
		console.log("Cron job started at:", new Date().toISOString());

		const timeWindow = getTimeWindow();
		console.log('Time window:', timeWindow);

		// GraphQL query 
		const query = `
			query Viewer {
				viewer {
					budget
					zones(filter: { zoneTag: "${env.ZONE_TAG}" }, limit: 1) {
						zoneTag
						firewallEventsAdaptiveGroups(
							filter: { 
								datetime_geq: "${timeWindow.start}",
								datetime_leq: "${timeWindow.end}",
								clientAsn_notlike: "13335"
							}
							orderBy: [count_DESC]
							limit: 25
						) {
							count
							dimensions {
								description 
								clientIP
								clientAsn
								action
								clientCountryName
								clientRequestPath
								ja4
								edgeResponseStatus
							}
						}
					}
				}
			}
		`;

		try {
			const response = await fetch('https://api.cloudflare.com/client/v4/graphql', {
				method: 'POST',
				headers: {
					'Authorization': `Bearer ${env.API_TOKEN}`,
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({ query })
			});

			const data = await response.json();

			// Get current events
			const currentEvents = data.data?.viewer?.zones[0]?.firewallEventsAdaptiveGroups || [];

			console.log('Current Events:', JSON.stringify(currentEvents, null, 2));
			
			// Bug - Skip processing if no events found
			if (currentEvents.length === 0) {
				console.log('No events found in the time window, skipping processing');
				return;
			}
			
			// Get previous state hash from KV
			const previousHash = await env.ALERTS_KV.get(STATE_KEY);
			console.log('Previous Hash:', previousHash);
			
			// Create simple hash of current events
			const currentHash = getSimpleHash(currentEvents);
			console.log('Current Hash:', currentHash);
			
			// Check if KV expired (previousHash is null) and if there are actual events
			const isKvExpired = previousHash === null;
			const hasActualEvents = currentEvents.length > 0;
			
			// Only trigger alert if:
			// 1. KV expired AND there are actual events, OR
			// 2. KV didn't expire AND hash changed
			const shouldTriggerAlert = (isKvExpired && hasActualEvents) || (!isKvExpired && previousHash !== currentHash);
			
			console.log('KV Expired:', isKvExpired);
			console.log('Has Actual Events:', hasActualEvents);
			console.log('Should Trigger Alert:', shouldTriggerAlert);

			// Only update KV and send alert if conditions are met
			if (shouldTriggerAlert) {
				console.log('Conditions met, updating KV store and sending alert');
				await env.ALERTS_KV.put(STATE_KEY, currentHash);

				console.log('Sending alert for new events');
				await sendAlert(currentEvents, env.ZONE_TAG, env);
			} else {
				console.log('Conditions not met, skipping KV update and alert');
			}

			console.log("Cron job completed successfully at:", new Date().toISOString());
		} catch (error) {
			console.error('Error in cron job:', error);
		}
	},
};